---
title: chromev8
date: 2020-08-08 22:32:57
tags: browser
---

### 编译器

编译型语言在程序执行之前需要先经过编译，将其编译为机器可以理解的二进制文件，c/c++ go
编译过程：

源代码——>词法分析、语法分析->AST->生成中间代码->代码优化->二进制文件->执行

### 解释器

解释型语言需要每次在运行时都对程序进行动态解释再执行

编译过程：

源代码——>词法分析、语法分析->AST->字节码->解释执行->执行

### v8 如何执行一段代码

![](/images/v8.png)

1.生成抽象语法树和执行上下文
AST 是一种结构，生成它的步骤：分词（tokenize)，将代码分成最小单元；解析，语法分析，将token 数据转成AST

2.生成字节码

一开始v8没有字节码，直接将AST装成机器码，执行效率非常高，但是占用内存大，低端机器扛不住。
为了解决内存问题，引入了字节码。

字节码：介于AST 和 机器之前的一种代码，需要被解释器转成机器码了才能执行

机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用

3.执行阶段

通常，第一次执行的字节码，解释器lgnition和逐条解释。在执行的字节码的过程中，
如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率

### 即时编译 JIT

字节码 与 解释器、编译器相结合；
v8中的解释： 代码每次执行的时候都会进行编译，编译为字节码的时候，解释器需要进行逐条解释，但是如果这段代码被标记为了热点代码，编译器就将它直接编译为了机器代码并保存在内存中，
下次会直接使用内存中的机器码，而不需要逐条解释为机器码

### js性能优化

代码层面的优化，v8已经做到极致了，我们要将重心放在单次脚本的运行时间和网络下载上

1.单次脚本的执行时间
2.避免过大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；
3.减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存
